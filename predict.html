<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blue Shark Tracking - Interactive Map</title>
    
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ¦ˆ</text></svg>">
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- Custom CSS -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #f5f5f5;
        }

        .header {
            background-color: #2c3e50;
            color: white;
            padding: 1rem 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
        }

        .header-title {
            flex: 1;
        }

        .header-title h1 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .header-title p {
            font-size: 1rem;
            opacity: 0.9;
        }

        .nav-tabs {
            display: flex;
            gap: 0;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 4px;
        }

        .nav-tab {
            padding: 10px 20px;
            text-decoration: none;
            color: rgba(255, 255, 255, 0.7);
            border-radius: 6px;
            transition: all 0.3s ease;
            font-weight: 500;
            font-size: 0.9rem;
        }

        .nav-tab:hover {
            color: white;
            background: rgba(255, 255, 255, 0.1);
        }

        .nav-tab.active {
            color: white;
            background: #3498db;
        }

        .container {
            display: flex;
            height: calc(100vh - 120px);
            position: relative;
        }

        .menu-toggle {
            position: absolute;
            top: 10px;
            left: 365px; /* 350px sidebar width + 15px spacing */
            z-index: 1001;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: left 0.3s ease, background-color 0.2s ease;
        }

        .container.sidebar-hidden .menu-toggle {
            left: 15px; /* 15px from left when sidebar is hidden */
        }

        .menu-toggle:hover {
            background: rgba(255, 255, 255, 1);
        }

        .menu-toggle svg {
            display: block;
        }

        .sidebar {
            width: 350px;
            background-color: white;
            box-shadow: 2px 0 4px rgba(0,0,0,0.1);
            padding: 1.5rem;
            transition: transform 0.3s ease;
            z-index: 1000;
            overflow-y: auto;
        }

        .sidebar.hidden {
            transform: translateX(-100%);
        }

        .sidebar h3 {
            color: #2c3e50;
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .controls {
            margin-bottom: 2rem;
        }

        .control-group {
            margin-bottom: 1rem;
        }

        .control-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
            color: #34495e;
        }

        .control-group button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .control-group button:hover {
            background-color: #2980b9;
        }

        .control-group button.active {
            background-color: #27ae60;
        }

        /* Loading indicator styles */
        .button-loading {
            position: relative;
            pointer-events: none;
            opacity: 0.7;
        }
        
        .button-loading::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            top: 50%;
            right: -25px;
            margin-top: -8px;
            border: 2px solid transparent;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }



        #map {
            flex: 1;
            position: relative;
            transition: margin-left 0.3s ease;
        }

        .container.sidebar-hidden #map {
            margin-left: -350px;
        }

        .legend {
            position: absolute;
            top: 60px; /* Below the menu toggle button */
            left: 15px; /* Same as menu toggle when sidebar is open */
            z-index: 1000;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 0.75rem;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
            cursor: pointer;
            min-width: 120px;
            backdrop-filter: blur(5px);
        }

        .legend:hover {
            background-color: rgba(255, 255, 255, 0.95);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .container.sidebar-hidden .legend {
            left: 15px; /* 15px from left when sidebar is hidden */
        }

        .legend.collapsed {
            padding: 0.5rem 0.75rem;
        }

        .legend-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .legend.collapsed .legend-header {
            margin-bottom: 0;
        }

        .legend-title {
            font-weight: bold;
            color: #2c3e50;
            font-size: 0.9rem;
        }

        .legend-toggle {
            font-size: 0.8rem;
            color: #7f8c8d;
            margin-left: 0.5rem;
        }

        .legend-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .legend.collapsed .legend-content {
            max-height: 0;
            opacity: 0;
            margin-top: 0;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.3rem;
            font-size: 0.85rem;
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .legend-color {
            width: 14px;
            height: 14px;
            margin-right: 0.5rem;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }

        .legend-emoji {
            font-size: 16px;
            margin-right: 0.5rem;
            flex-shrink: 0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .legend-text {
            color: #2c3e50;
            line-height: 1.2;
        }

        .shark-list {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 0.5rem;
            background-color: #fafafa;
        }

        .shark-item {
            padding: 0.75rem;
            border: 1px solid #ecf0f1;
            border-radius: 4px;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .shark-item:hover {
            background-color: #ecf0f1;
        }

        .shark-item.selected {
            background-color: #e8f4f8;
            border-color: #3498db;
        }

        .shark-id {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }

        .shark-details {
            font-size: 0.85rem;
            color: #7f8c8d;
        }

        .shark-details div {
            margin-bottom: 0.2rem;
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: #7f8c8d;
        }

        .stats {
            background-color: #ecf0f1;
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
        }

        .stats h4 {
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .stats-item {
            display: flex;
            justify-content: space-between;
        }

        .stats-label {
            color: #7f8c8d;
        }

        .stats-value {
            font-weight: bold;
            color: #2c3e50;
        }



        /* Notification styles */
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #3498db;
            color: white;
            padding: 16px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(52, 152, 219, 0.3);
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 10000;
            cursor: pointer;
            animation: slideDown 0.3s ease-out;
            max-width: 400px;
            text-align: center;
            border-left: 4px solid #2980b9;
        }

        .notification:hover {
            background: #2980b9;
            transform: translateX(-50%) scale(1.02);
            transition: all 0.2s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .notification.fadeOut {
            animation: fadeOut 0.3s ease-out forwards;
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px);
            }
        }

        @keyframes shark-pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.3);
            }
        }


    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div class="header-title">
                <h1>Blue Shark Tracking Project</h1>
                <p>Interactive map showing satellite tracking data of blue sharks (Prionace glauca) in the North Atlantic</p>
            </div>
            <nav class="nav-tabs">
                <a href="index.html" class="nav-tab">Our Mission</a>
                <a href="map.html" class="nav-tab">2D Map</a>
                <a href="predict.html" class="nav-tab active">Prediction</a>
				<a href="globe.html" class="nav-tab">3D Map</a>
                <a href="model.html" class="nav-tab">Bio-tag</a>
            </nav>
        </div>
    </div>

    <div class="container">
        <!-- Menu toggle button -->
        <button class="menu-toggle" id="menu-toggle" title="Toggle Sidebar">
            <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#5f6368">
                <path d="M120-240v-80h720v80H120Zm0-200v-80h720v80H120Zm0-200v-80h720v80H120Z"/>
            </svg>
        </button>
        
        <div class="sidebar" id="sidebar">
            <div class="stats">
                <h4>Dataset Summary</h4>
                <div class="stats-grid">
                    <div class="stats-item">
                        <span class="stats-label">Total Sharks:</span>
                        <span class="stats-value" id="total-sharks">-</span>
                    </div>
                    <div class="stats-item">
                        <span class="stats-label">Total Points:</span>
                        <span class="stats-value" id="total-points">-</span>
                    </div>
                    <div class="stats-item">
                        <span class="stats-label">Date Range:</span>
                        <span class="stats-value" id="date-range">-</span>
                    </div>
                    <div class="stats-item">
                        <span class="stats-label">Species:</span>
                        <span class="stats-value">Blue Shark</span>
                    </div>
                </div>
            </div>

            <div class="controls">
                <h3>Map Controls</h3>
                <div class="control-group">
                    <label>Display Mode</label>
                    <button id="show-all" class="active">Show All</button>
                    <button id="show-one">Show One</button>
                </div>
                <div class="control-group">
                    <label>Marine Protected Areas</label>
                    <button id="toggle-mpa">Load MPAs</button>
                </div>
            </div>

            <h3>Tracked Sharks</h3>
            <div id="shark-list" class="shark-list">
                <div class="loading">Loading shark data...</div>
            </div>
        </div>

        <div id="map">
            <!-- Legend overlay -->
            <div class="legend" id="legend">
                <div class="legend-header">
                    <span class="legend-title">Legend</span>
                    <span class="legend-toggle">â–¼</span>
                </div>
                <div class="legend-content" id="legend-content">
                    <!-- Dynamic content will be populated by JavaScript -->
                </div>
            </div>

        </div>
        <!-- Intro Section -->
        <section id="intro" style="display: none;">
            <h2>Welcome to the Blue Shark Tracking Project</h2>
            <p>This interactive map visualizes satellite tracking data of blue sharks (Prionace glauca) in the North Atlantic. Use the controls to explore individual shark movements, view deployment locations, and analyze their swimming tracks over time.</p>
            <p>Data Source: <a href="https://www.seaturtle.org/tracking/" target="_blank" rel="noopener noreferrer">SEATURTLE.ORG</a></p>
        </section><!-- --- IGNORE --- -->
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Papa Parse for CSV reading -->
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
    
    <!-- Shapefile library for handling shapefiles -->
    <script src="https://unpkg.com/shapefile@0.6.6/dist/shapefile.js"></script>

    <script>
        // Global variables
        let map;
        let sharkData = {};
        let sharkLayers = {};
        let allBounds = [];
        
        // MPA variables
        let mpaLayer = null;
        let showMPA = false;
        
        // Show one mode variables
        let showOneMode = false;
        let selectedSharkId = null;

        // ISO3 to country name mapping
        const iso3ToCountry = {
            'ABNJ': 'Area Beyond National Jurisdiction', 'AFG': 'Afghanistan', 'ALB': 'Albania', 'DZA': 'Algeria', 'ASM': 'American Samoa', 'AND': 'Andorra',
            'AGO': 'Angola', 'AIA': 'Anguilla', 'ATA': 'Antarctica', 'ATG': 'Antigua and Barbuda', 'ARG': 'Argentina',
            'ARM': 'Armenia', 'ABW': 'Aruba', 'AUS': 'Australia', 'AUT': 'Austria', 'AZE': 'Azerbaijan',
            'BHS': 'Bahamas', 'BHR': 'Bahrain', 'BGD': 'Bangladesh', 'BRB': 'Barbados', 'BLR': 'Belarus',
            'BEL': 'Belgium', 'BLZ': 'Belize', 'BEN': 'Benin', 'BMU': 'Bermuda', 'BTN': 'Bhutan',
            'BOL': 'Bolivia', 'BES': 'Bonaire, Sint Eustatius and Saba', 'BIH': 'Bosnia and Herzegovina', 'BWA': 'Botswana', 'BVT': 'Bouvet Island',
            'BRA': 'Brazil', 'IOT': 'British Indian Ocean Territory', 'BRN': 'Brunei', 'BGR': 'Bulgaria', 'BFA': 'Burkina Faso',
            'BDI': 'Burundi', 'CPV': 'Cabo Verde', 'KHM': 'Cambodia', 'CMR': 'Cameroon', 'CAN': 'Canada',
            'CYM': 'Cayman Islands', 'CAF': 'Central African Republic', 'TCD': 'Chad', 'CHL': 'Chile', 'CHN': 'China',
            'CXR': 'Christmas Island', 'CCK': 'Cocos (Keeling) Islands', 'COL': 'Colombia', 'COM': 'Comoros', 'COG': 'Congo',
            'COD': 'Congo (Democratic Republic)', 'COK': 'Cook Islands', 'CRI': 'Costa Rica', 'CIV': 'CÃ´te d\'Ivoire', 'HRV': 'Croatia',
            'CUB': 'Cuba', 'CUW': 'CuraÃ§ao', 'CYP': 'Cyprus', 'CZE': 'Czech Republic', 'DNK': 'Denmark',
            'DJI': 'Djibouti', 'DMA': 'Dominica', 'DOM': 'Dominican Republic', 'ECU': 'Ecuador', 'EGY': 'Egypt',
            'SLV': 'El Salvador', 'GNQ': 'Equatorial Guinea', 'ERI': 'Eritrea', 'EST': 'Estonia', 'SWZ': 'Eswatini',
            'ETH': 'Ethiopia', 'FLK': 'Falkland Islands', 'FRO': 'Faroe Islands', 'FJI': 'Fiji', 'FIN': 'Finland',
            'FRA': 'France', 'GUF': 'French Guiana', 'PYF': 'French Polynesia', 'ATF': 'French Southern Territories', 'GAB': 'Gabon',
            'GMB': 'Gambia', 'GEO': 'Georgia', 'DEU': 'Germany', 'GHA': 'Ghana', 'GIB': 'Gibraltar',
            'GRC': 'Greece', 'GRL': 'Greenland', 'GRD': 'Grenada', 'GLP': 'Guadeloupe', 'GUM': 'Guam',
            'GTM': 'Guatemala', 'GGY': 'Guernsey', 'GIN': 'Guinea', 'GNB': 'Guinea-Bissau', 'GUY': 'Guyana',
            'HTI': 'Haiti', 'HMD': 'Heard Island and McDonald Islands', 'VAT': 'Holy See', 'HND': 'Honduras', 'HKG': 'Hong Kong',
            'HUN': 'Hungary', 'ISL': 'Iceland', 'IND': 'India', 'IDN': 'Indonesia', 'IRN': 'Iran',
            'IRQ': 'Iraq', 'IRL': 'Ireland', 'IMN': 'Isle of Man', 'ISR': 'Israel', 'ITA': 'Italy',
            'JAM': 'Jamaica', 'JPN': 'Japan', 'JEY': 'Jersey', 'JOR': 'Jordan', 'KAZ': 'Kazakhstan',
            'KEN': 'Kenya', 'KIR': 'Kiribati', 'PRK': 'North Korea', 'KOR': 'South Korea', 'KWT': 'Kuwait',
            'KGZ': 'Kyrgyzstan', 'LAO': 'Laos', 'LVA': 'Latvia', 'LBN': 'Lebanon', 'LSO': 'Lesotho',
            'LBR': 'Liberia', 'LBY': 'Libya', 'LIE': 'Liechtenstein', 'LTU': 'Lithuania', 'LUX': 'Luxembourg',
            'MAC': 'Macao', 'MDG': 'Madagascar', 'MWI': 'Malawi', 'MYS': 'Malaysia', 'MDV': 'Maldives',
            'MLI': 'Mali', 'MLT': 'Malta', 'MHL': 'Marshall Islands', 'MTQ': 'Martinique', 'MRT': 'Mauritania',
            'MUS': 'Mauritius', 'MYT': 'Mayotte', 'MEX': 'Mexico', 'FSM': 'Micronesia', 'MDA': 'Moldova',
            'MCO': 'Monaco', 'MNG': 'Mongolia', 'MNE': 'Montenegro', 'MSR': 'Montserrat', 'MAR': 'Morocco',
            'MOZ': 'Mozambique', 'MMR': 'Myanmar', 'NAM': 'Namibia', 'NRU': 'Nauru', 'NPL': 'Nepal',
            'NLD': 'Netherlands', 'NCL': 'New Caledonia', 'NZL': 'New Zealand', 'NIC': 'Nicaragua', 'NER': 'Niger',
            'NGA': 'Nigeria', 'NIU': 'Niue', 'NFK': 'Norfolk Island', 'MKD': 'North Macedonia', 'MNP': 'Northern Mariana Islands',
            'NOR': 'Norway', 'OMN': 'Oman', 'PAK': 'Pakistan', 'PLW': 'Palau', 'PSE': 'Palestine',
            'PAN': 'Panama', 'PNG': 'Papua New Guinea', 'PRY': 'Paraguay', 'PER': 'Peru', 'PHL': 'Philippines',
            'PCN': 'Pitcairn', 'POL': 'Poland', 'PRT': 'Portugal', 'PRI': 'Puerto Rico', 'QAT': 'Qatar',
            'REU': 'RÃ©union', 'ROU': 'Romania', 'RUS': 'Russia', 'RWA': 'Rwanda', 'BLM': 'Saint BarthÃ©lemy',
            'SHN': 'Saint Helena', 'KNA': 'Saint Kitts and Nevis', 'LCA': 'Saint Lucia', 'MAF': 'Saint Martin',
            'SPM': 'Saint Pierre and Miquelon', 'VCT': 'Saint Vincent and the Grenadines', 'WSM': 'Samoa', 'SMR': 'San Marino', 'STP': 'Sao Tome and Principe',
            'SAU': 'Saudi Arabia', 'SEN': 'Senegal', 'SRB': 'Serbia', 'SYC': 'Seychelles', 'SLE': 'Sierra Leone',
            'SGP': 'Singapore', 'SXM': 'Sint Maarten', 'SVK': 'Slovakia', 'SVN': 'Slovenia', 'SLB': 'Solomon Islands',
            'SOM': 'Somalia', 'ZAF': 'South Africa', 'SGS': 'South Georgia and the South Sandwich Islands', 'SSD': 'South Sudan', 'ESP': 'Spain',
            'LKA': 'Sri Lanka', 'SDN': 'Sudan', 'SUR': 'Suriname', 'SJM': 'Svalbard and Jan Mayen', 'SWE': 'Sweden',
            'CHE': 'Switzerland', 'SYR': 'Syria', 'TWN': 'Taiwan', 'TJK': 'Tajikistan', 'TZA': 'Tanzania',
            'THA': 'Thailand', 'TLS': 'Timor-Leste', 'TGO': 'Togo', 'TKL': 'Tokelau', 'TON': 'Tonga',
            'TTO': 'Trinidad and Tobago', 'TUN': 'Tunisia', 'TUR': 'Turkey', 'TKM': 'Turkmenistan', 'TCA': 'Turks and Caicos Islands',
            'TUV': 'Tuvalu', 'UGA': 'Uganda', 'UKR': 'Ukraine', 'ARE': 'United Arab Emirates', 'GBR': 'United Kingdom',
            'USA': 'United States', 'UMI': 'United States Minor Outlying Islands', 'URY': 'Uruguay', 'UZB': 'Uzbekistan', 'VUT': 'Vanuatu',
            'VEN': 'Venezuela', 'VNM': 'Vietnam', 'VGB': 'Virgin Islands (British)', 'VIR': 'Virgin Islands (U.S.)', 'WLF': 'Wallis and Futuna',
            'ESH': 'Western Sahara', 'YEM': 'Yemen', 'ZMB': 'Zambia', 'ZWE': 'Zimbabwe'
        };

        // Function to get country name from ISO3 code
        // Handles both single codes and multiple codes separated by semicolons (for transboundary sites)
        function getCountryName(iso3Code) {
            if (!iso3Code) {
                return 'Unknown';
            }
            
            // Check if this is a transboundary site (contains semicolons)
            if (iso3Code.includes(';')) {
                const codes = iso3Code.split(';');
                const countryNames = codes.map(code => {
                    const trimmedCode = code.trim();
                    return iso3ToCountry[trimmedCode] || trimmedCode;
                }).filter(name => name); // Remove any empty names
                
                return countryNames.length > 0 ? countryNames.join(' & ') : 'Unknown';
            } else {
                // Single country code
                return iso3ToCountry[iso3Code] || iso3Code || 'Unknown';
            }
        }

        // SVG icons for visibility toggle buttons
        const EYE_VISIBLE_ICON = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#2c3e50"><path d="M480-320q75 0 127.5-52.5T660-500q0-75-52.5-127.5T480-680q-75 0-127.5 52.5T300-500q0 75 52.5 127.5T480-320Zm0-72q-45 0-76.5-31.5T372-500q0-45 31.5-76.5T480-608q45 0 76.5 31.5T588-500q0 45-31.5 76.5T480-392Zm0 192q-146 0-266-81.5T40-500q54-137 174-218.5T480-800q146 0 266 81.5T920-500q-54 137-174 218.5T480-200Zm0-300Zm0 220q113 0 207.5-59.5T832-500q-50-101-144.5-160.5T480-720q-113 0-207.5 59.5T128-500q50 101 144.5 160.5T480-280Z"/></svg>';
        const EYE_HIDDEN_ICON = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#95a5a6"><path d="m644-428-58-58q9-47-27-88t-93-32l-58-58q17-8 34.5-12t37.5-4q75 0 127.5 52.5T660-500q0 20-4 37.5T644-428Zm128 126-58-56q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-62-62q41-17 84-25.5t90-8.5q151 0 269 83.5T920-500q-23 59-60.5 109.5T772-302Zm20 246L624-222q-35 11-70.5 16.5T480-200q-151 0-269-83.5T40-500q21-53 53-98.5t73-81.5L56-792l56-56 736 736-56 56ZM222-624q-29 26-53 57t-41 67q50 101 143.5 160.5T480-280q20 0 39-2.5t39-5.5l-36-38q-11 3-21 4.5t-21 1.5q-75 0-127.5-52.5T300-500q0-11 1.5-21t4.5-21l-84-82Zm319 93Zm-151 75Z"/></svg>';

        // Color palette for different sharks
        const colors = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
            '#1abc9c', '#34495e', '#e67e22', '#ff6b6b', '#e91e63',
            '#00bcd4', '#ff5722', '#795548', '#607d8b', '#ffc107'
        ];

        // Calculate distance between two lat/lon points using Haversine formula
        function calculateDistance(track) {
            if (track.length < 2) return 0;
            
            let totalDistance = 0;
            for (let i = 1; i < track.length; i++) {
                const R = 6371; // Earth's radius in km
                const dLat = (track[i].lat - track[i-1].lat) * Math.PI / 180;
                const dLon = (track[i].lon - track[i-1].lon) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(track[i-1].lat * Math.PI / 180) * Math.cos(track[i].lat * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                totalDistance += R * c;
            }
            return totalDistance;
        }

        // Show notification function
        function showNotification(message, duration = 5000) {
            // Remove existing notification if any
            const existingNotification = document.querySelector('.notification');
            if (existingNotification) {
                existingNotification.remove();
            }

            // Create notification element
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            
            // Add click to dismiss functionality
            notification.addEventListener('click', () => {
                notification.classList.add('fadeOut');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                }, 300);
            });

            // Add to document
            document.body.appendChild(notification);

            // Auto-dismiss after duration
            setTimeout(() => {
                if (notification.parentNode && !notification.classList.contains('fadeOut')) {
                    notification.classList.add('fadeOut');
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.remove();
                        }
                    }, 300);
                }
            }, duration);
        }

        // Load MPA data from shapefiles and create layer
        async function loadMPALayer() {
            console.log('Loading MPA data from shapefiles...');
            
            // Show loading indicator on button
            const mpaButton = document.getElementById('toggle-mpa');
            if (mpaButton) {
                mpaButton.classList.add('button-loading');
                mpaButton.textContent = 'Loading MPAs...';
            }
            
            // Show loading notification
            showNotification('Loading Marine Protected Areas...', 2000);
            
            if (mpaLayer) {
                map.removeLayer(mpaLayer);
            }
            
            mpaLayer = L.layerGroup();
            
            const shapefiles = ['0ps', '1ps', '2ps'];
            let totalFeatures = 0;
            
            try {
                for (let i = 0; i < shapefiles.length; i++) {
                    const filename = shapefiles[i];
                    console.log(`Loading ${filename}.shp... (${i + 1}/${shapefiles.length})`);
                    
                    // Update button text with progress
                    if (mpaButton) {
                        mpaButton.textContent = `Loading MPAs... (${i + 1}/${shapefiles.length})`;
                    }
                    
                    // Load the shapefile
                    const collection = await shapefile.read(`data/mpa/${filename}.shp`);
                    
                    if (collection && collection.features) {
                        console.log(`Loaded ${collection.features.length} features from ${filename}.shp`);
                        
                        collection.features.forEach(feature => {
                            if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
                                // Convert GeoJSON to Leaflet layer
                                const leafletLayer = L.geoJSON(feature, {
                                    style: {
                                        color: '#1e88e5',
                                        weight: 1,
                                        opacity: 0.7,
                                        fillColor: '#42a5f5',
                                        fillOpacity: 0.15
                                    },
                                    onEachFeature: (feature, layer) => {
                                        // Create popup with MPA information
                                        const props = feature.properties || {};
                                        const popupContent = `
                                            <div style="font-family: Arial, sans-serif; max-width: 250px;">
                                                <h4 style="margin: 0 0 10px 0; color: #1565c0;">${props.NAME || 'Marine Protected Area'}</h4>
                                                <p><strong>ID:</strong> ${props.WDPAID || 'N/A'}</p>
                                                <p><strong>Designation:</strong> ${props.DESIG_ENG || props.DESIG || 'Protected Area'}</p>
                                                <p><strong>Country:</strong> ${getCountryName(props.ISO3)}</p>
                                                <p><strong>Status:</strong> ${props.STATUS || 'Unknown'}</p>
                                                <p><strong>Marine Area:</strong> ${props.REP_M_AREA ? parseFloat(props.REP_M_AREA).toFixed(2) + ' kmÂ²' : 'Unknown'}</p>
                                                </div>
                                                `;
                                                // <p><strong>IUCN Category:</strong> ${props.IUCN_CAT || 'Not specified'}</p>
                                        layer.bindPopup(popupContent);
                                    }
                                });
                                
                                mpaLayer.addLayer(leafletLayer);
                                totalFeatures++;
                            }
                        });
                    }
                }
                
                console.log(`Total MPA features loaded: ${totalFeatures}`);
                
                // Remove loading indicator and update button
                if (mpaButton) {
                    mpaButton.classList.remove('button-loading');
                    mpaButton.textContent = `Show MPAs (${totalFeatures} zones)`;
                }
                
                // Show success notification
                showNotification(`Successfully loaded ${totalFeatures} Marine Protected Areas`, 3000);
                
            } catch (error) {
                console.error('Error loading MPA shapefiles:', error);
                
                // Remove loading indicator on error
                if (mpaButton) {
                    mpaButton.classList.remove('button-loading');
                    mpaButton.textContent = 'Show MPAs (Error)';
                }
                
                showNotification('Error loading MPA data. Please check that shapefile files are available.', 5000);
            }
        }

        // Toggle MPA layer visibility
        async function toggleMPALayer() {
            const toggleButton = document.getElementById('toggle-mpa');
            
            // Prevent clicking while loading
            if (toggleButton && toggleButton.classList.contains('button-loading')) {
                return;
            }
            
            if (!mpaLayer) {
                await loadMPALayer();
                return;
            }
            
            if (showMPA) {
                // Hide MPA layer
                if (mpaLayer && map.hasLayer(mpaLayer)) {
                    map.removeLayer(mpaLayer);
                }
                showMPA = false;
                toggleButton.classList.remove('active');
                const count = toggleButton.textContent.match(/\((\d+)\)/);
                if (count) {
                    toggleButton.textContent = `Show MPAs (${count[1]} zones)`;
                } else {
                    toggleButton.textContent = 'Show MPAs';
                }
            } else {
                // Show MPA layer
                if (mpaLayer) {
                    map.addLayer(mpaLayer);
                }
                showMPA = true;
                toggleButton.classList.add('active');
                const count = toggleButton.textContent.match(/\((\d+)\)/);
                if (count) {
                    toggleButton.textContent = `Hide MPAs (${count[1]} zones)`;
                } else {
                    toggleButton.textContent = 'Hide MPAs';
                }
            }
            
            // Update legend to show/hide MPA item
            updateLegendContent();
        }

        // Removed environmental layer functions - no longer needed
        /*
        function toggleChlorophyllLayer() {
            const toggleButton = document.getElementById('toggle-chlorophyll');
            const chlScale = document.getElementById('chl-scale');
            const sstScale = document.getElementById('sst-scale');
            const pocScale = document.getElementById('poc-scale');
            
            if (showChlorophyll) {
                // Hide Chlorophyll layer
                if (chlorophyllLayer && map.hasLayer(chlorophyllLayer)) {
                    map.removeLayer(chlorophyllLayer);
                }
                showChlorophyll = false;
                toggleButton.classList.remove('active');
                toggleButton.textContent = 'Chlorophyll';
                
                // Hide chlorophyll scale
                chlScale.classList.remove('visible');
                
                // Adjust SST scale position if it's visible
                if (showSST) {
                    sstScale.classList.remove('with-chl-scale');
                }

                // Adjust POC scale position if it's visible
                if (showPOC) {
                    pocScale.classList.remove('with-chl-sst-scale');
                    if (showSST) {
                        pocScale.classList.add('with-chl-scale');
                    } else {
                        pocScale.classList.remove('with-chl-scale');
                    }
                }
            } else {
                // Show Chlorophyll layer
                showChlorophyll = true;
                toggleButton.classList.add('active');
                toggleButton.textContent = 'Hide Chlorophyll';
                
                // Show chlorophyll scale
                chlScale.classList.add('visible');
                
                // Adjust SST scale position if it's visible
                if (showSST) {
                    sstScale.classList.add('with-chl-scale');
                }
                
                // Adjust POC scale position if it's visible
                if (showPOC) {
                    if (showSST) {
                        pocScale.classList.add('with-chl-sst-scale');
                    } else {
                        pocScale.classList.add('with-chl-scale');
                    }
                }
            }
            updateEnvironmentalLayers();
            
            // Update legend
            updateLegendContent();
            
            // Update time slider text color
            updateTimeSliderTextColor();
            
            // Update max zoom constraint
            updateMaxZoom();
        }

        // Toggle SST layer visibility
        function toggleSSTLayer() {
            const toggleButton = document.getElementById('toggle-sst');
            const chlScale = document.getElementById('chl-scale');
            const sstScale = document.getElementById('sst-scale');
            const pocScale = document.getElementById('poc-scale');
            
            if (showSST) {
                // Hide SST layer
                if (sstLayer && map.hasLayer(sstLayer)) {
                    map.removeLayer(sstLayer);
                }
                showSST = false;
                toggleButton.classList.remove('active');
                toggleButton.textContent = 'Sea Surface Temp';
                
                // Hide SST scale
                sstScale.classList.remove('visible');
                sstScale.classList.remove('with-chl-scale');

                // Adjust POC scale position if it's visible
                if (showPOC) {
                    if (showChlorophyll) {
                        pocScale.classList.remove('with-chl-sst-scale');
                        pocScale.classList.add('with-chl-scale');
                    } else {
                        pocScale.classList.remove('with-chl-scale');
                    }
                }
            } else {
                // Show SST layer
                showSST = true;
                toggleButton.classList.add('active');
                toggleButton.textContent = 'Hide SST';
                
                // Show SST scale
                sstScale.classList.add('visible');
                
                // Adjust position if chlorophyll scale is also visible
                if (showChlorophyll) {
                    sstScale.classList.add('with-chl-scale');
                }
                // Adjust POC scale position if it's visible
                if (showPOC) {
                    if (showChlorophyll) {
                        pocScale.classList.add('with-chl-sst-scale');
                    } else {
                        pocScale.classList.add('with-chl-scale');
                    }
                }
            }
            updateEnvironmentalLayers();

            // Update legend
            updateLegendContent();
            
            // Update time slider text color
            updateTimeSliderTextColor();
            
            // Update max zoom constraint
            updateMaxZoom();
        }

        // Toggle POC layer visibility
        function togglePOCLayer() {
            const toggleButton = document.getElementById('toggle-poc');
            const chlScale = document.getElementById('chl-scale');
            const sstScale = document.getElementById('sst-scale');
            const pocScale = document.getElementById('poc-scale');
            
            if (showPOC) {
                // Hide POC layer
                if (pocLayer && map.hasLayer(pocLayer)) {
                    map.removeLayer(pocLayer);
                }
                showPOC = false;
                toggleButton.classList.remove('active');
                toggleButton.textContent = 'POC';
                
                // Hide POC scale and adjust other scales
                pocScale.classList.remove('visible');
                pocScale.classList.remove('with-chl-scale', 'with-sst-scale', 'with-chl-sst-scale');
                
                // Adjust SST scale position if it's visible
                if (showSST && !showChlorophyll) {
                    sstScale.classList.remove('with-chl-scale');
                }
            } else {
                // Show POC layer
                showPOC = true;
                toggleButton.classList.add('active');
                toggleButton.textContent = 'Hide POC';
                
                // Show POC scale and adjust positioning
                pocScale.classList.add('visible');
                
                // Adjust position based on other visible scales
                if (showChlorophyll && showSST) {
                    pocScale.classList.add('with-chl-sst-scale');
                } else if (showChlorophyll || showSST) {
                    pocScale.classList.add('with-chl-scale');
                }
            }
            updateEnvironmentalLayers();
            
            // Update legend
            updateLegendContent();
            
            // Update time slider text color
            updateTimeSliderTextColor();
            
            // Update max zoom constraint
            updateMaxZoom();
        }

        // Function to update time slider text color based on active layers
        function updateTimeSliderTextColor() {
            const timeLabels = document.querySelector('.time-labels');
            if (!timeLabels) return;

            // Check if we should use white text
            const useWhiteText = showChlorophyll || showSST || showPOC || currentBaseLayer === 'Satellite';
            
            if (useWhiteText) {
                timeLabels.classList.add('white-text');
            } else {
                timeLabels.classList.remove('white-text');
            }
        }

        // Function to update max zoom based on environmental layer visibility
        function updateMaxZoom() {
            // If any environmental layer is visible, limit zoom to 6
            if (showChlorophyll || showSST || showPOC) {
                map.setMaxZoom(6);
                // If current zoom is greater than 6, zoom out to 6
                if (map.getZoom() > 6) {
                    map.setZoom(6);
                }
            } else {
                // No environmental layers, allow full zoom (20)
                map.setMaxZoom(20);
            }
        }

        // Function to update environmental layers based on current timestamp
        function updateEnvironmentalLayers() {
            // Only show environmental layers in show one mode
            if (!showOneMode || !selectedSharkId || !sharkData[selectedSharkId]) {
                return;
            }

            const track = sharkData[selectedSharkId];
            if (!track || track.length === 0 || currentTimeIndex >= track.length) {
                return;
            }

            const currentPoint = track[currentTimeIndex];
            const currentDate = currentPoint.date;
            
            // Format date for tile naming (YYYY-MM-DD format)
            const year = currentDate.getFullYear();
            const month = String(currentDate.getMonth() + 1).padStart(2, '0');
            const day = '01'; // Use first day of month for monthly data
            const dateString = `${year}-${month}-${day}`;
            const monthKey = `${year}-${month}`; // Key for month comparison
            
            // Check if we need to update tiles (only if month has changed OR layers don't exist yet)
            const monthChanged = currentEnvironmentalMonth !== monthKey;
            const needsInitialization = (showPOC && !pocLayer) || (showSST && !sstLayer) || (showChlorophyll && !chlorophyllLayer);

            if (monthChanged || needsInitialization) {
                if (monthChanged) {
                    // console.log(`Environmental layers: Month changed from ${currentEnvironmentalMonth} to ${monthKey}`);
                }
                currentEnvironmentalMonth = monthKey;
                
                // const baseUrl = 'http://localhost:8001'; // Change this to your server URL
                // const baseUrl = 'https://www.csie.ntu.edu.tw/~b12902118/Nasa-Space-App';
                const baseUrl = 'https://lebullient.github.io/Nasa-Space-App/';

                // Update POC layer if it's enabled
                if (showPOC) {
                    // Remove old layer
                    if (pocLayer && map.hasLayer(pocLayer)) {
                        map.removeLayer(pocLayer);
                    }
                    // Create new layer with updated date
                    const pocTileUrl = `${baseUrl}/tiles/poc/${dateString}/{z}/{x}/{y}.png`;
                    pocLayer = L.tileLayer(pocTileUrl, {
                        opacity: 0.6,
                        attribution: 'Particulate Organic Carbon Data',
                        errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==' // Transparent 1x1 pixel
                    });
                    map.addLayer(pocLayer);
                }

                // Update SST layer if it's enabled
                if (showSST) {
                    // Remove old layer
                    if (sstLayer && map.hasLayer(sstLayer)) {
                        map.removeLayer(sstLayer);
                    }
                    // Create new layer with updated date
                    const sstTileUrl = `${baseUrl}/tiles/sst/${dateString}/{z}/{x}/{y}.png`;
                    sstLayer = L.tileLayer(sstTileUrl, {
                        opacity: 0.6,
                        attribution: 'Sea Surface Temperature Data',
                        errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==' // Transparent 1x1 pixel
                    });
                    map.addLayer(sstLayer);
                }
                
                // Update Chlorophyll layer if it's enabled
                if (showChlorophyll) {
                    // Remove old layer
                    if (chlorophyllLayer && map.hasLayer(chlorophyllLayer)) {
                        map.removeLayer(chlorophyllLayer);
                    }
                    // Create new layer with updated date
                    const chlTileUrl = `${baseUrl}/tiles/chl/${dateString}/{z}/{x}/{y}.png`;
                    chlorophyllLayer = L.tileLayer(chlTileUrl, {
                        opacity: 0.6,
                        attribution: 'Chlorophyll Data',
                        errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==' // Transparent 1x1 pixel
                    });
                    map.addLayer(chlorophyllLayer);
                }
                
            } else {
                // Month hasn't changed, but we still need to ensure layers are visible if they should be
                if (showPOC && pocLayer && !map.hasLayer(pocLayer)) {
                    map.addLayer(pocLayer);
                }
                if (showSST && sstLayer && !map.hasLayer(sstLayer)) {
                    map.addLayer(sstLayer);
                }
                if (showChlorophyll && chlorophyllLayer && !map.hasLayer(chlorophyllLayer)) {
                    map.addLayer(chlorophyllLayer);
                }
            }
        }
        */

        // Initialize the map
        function initMap() {
            map = L.map('map', {
                renderer: L.canvas(), // Use canvas renderer for better performance with many points
                zoomControl: false, // Disable default zoom control
                scrollWheelZoom: true // Enable scroll wheel zoom by default
            }).setView([40.0, -60.0], 4);

            // Add base layers
            const oceanBase = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 20
            }).addTo(map);

            const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
            });

            // Layer control - add first so it appears on top
            const baseMaps = {
                "Ocean": oceanBase,
                "Satellite": satellite
            };

            const layerControl = L.control.layers(baseMaps, null, {
                position: 'topright'
            }).addTo(map);

            // Listen for base layer changes
            map.on('baselayerchange', function(e) {
                // Base layer changed
            });

            // Add zoom control on the right side - add after layer control so it appears below
            L.control.zoom({
                position: 'topright'
            }).addTo(map);
            
            // Add horizontal scale control at bottom right
            L.control.scale({
                position: 'bottomright',
                maxWidth: 200,
                metric: true,
                imperial: true,
                updateWhenIdle: false
            }).addTo(map);
        }

        // Load and parse CSV data from GBIF
        async function loadData() {
            try {
                console.log('Loading GBIF shark data...');
                
                // Get list of all CSV files in the GBIF directory
                const sharkFiles = [
                    'NSBS-1248824.csv', 'NSBS-1248825-2017-08-22.csv', 'NSBS-1248826-2017-08-25.csv',
                    'NSBS-1248827-2017-08-22.csv', 'NSBS-1248828-2017-08-27.csv', 'NSBS-1248829-2017-08-22.csv',
                    'NSBS-1248830.csv', 'NSBS-1248831-2017-08-22.csv', 'NSBS-1248832.csv', 'NSBS-1248833.csv',
                    'NSBS-1248834-2017-08-27.csv', 'NSBS-1248835-2019-07-14.csv', 'NSBS-1248836-2019-07-14.csv',
                    'NSBS-1248838-2017-08-22.csv', 'NSBS-1250978-2023-08-02.csv', 'NSBS-1250979-2019-09-06.csv',
                    'NSBS-1250980-2022-08-29.csv', 'NSBS-1250981-2019-09-06.csv', 'NSBS-1250982-2017-08-25.csv',
                    'NSBS-1250983-2022-08-23.csv', 'NSBS-1250984-2017-08-25.csv', 'NSBS-1250985-2022-08-23.csv',
                    'NSBS-1250986-2017-08-25.csv', 'NSBS-1270572-2023-08-04.csv', 'NSBS-1287530-2019-09-06.csv',
                    'NSBS-1287536-2019-09-06.csv', 'NSBS-1290429-2022-08-01.csv', 'NSBS-1290432-2022-08-02.csv',
                    'NSBS-1300141-2024-08-14.csv', 'NSBS-1300142-2024-08-14.csv', 'NSBS-1300144-2024-08-14.csv',
                    'NSBS-1393328-2021-08-05.csv', 'NSBS-1393329-2021-08-09.csv', 'NSBS-1393330-2021-08-05.csv',
                    'NSBS-1393331-2021-08-09.csv', 'NSBS-1393332-2021-08-05.csv', 'NSBS-1393333-2021-08-09.csv',
                    'NSBS-1393334-2021-08-08.csv', 'NSBS-1393335-2021-08-10.csv', 'NSBS-1393336-2021-08-08.csv',
                    'NSBS-1393337-2021-08-09.csv', 'NSBS-1393338-2021-08-08.csv', 'NSBS-1393340-2021-08-10.csv',
                    'NSBS-1393342-2021-08-10.csv', 'NSBS-411936.0-2022-08-01.csv', 'NSBS-ALI.csv',
                    'NSBS-Alison.csv', 'NSBS-Alyssa.csv', 'NSBS-Art-2019-08-25.csv', 'NSBS-Bee-2019-08-25.csv',
                    'NSBS-Betty.csv', 'NSBS-Big Momma.csv', 'NSBS-Blue Rodeo (Rick Mercer).csv', 'NSBS-Blueberry.csv',
                    'NSBS-Bonkers.csv', 'NSBS-Brandy.csv', 'NSBS-Brendal.csv', 'NSBS-Brianna.csv',
                    'NSBS-Byron-2019-08-25.csv', 'NSBS-CAITLIN.csv', 'NSBS-CAROLINA.csv', 'NSBS-Calypso.csv',
                    'NSBS-Casey.csv', 'NSBS-Cordelia-2019-08-25.csv', 'NSBS-Daisy.csv', 'NSBS-Dash.csv',
                    'NSBS-Duncan.csv', 'NSBS-ELVIRE.csv', 'NSBS-Eileen-2022-08-02.csv', 'NSBS-Elania-2019-08-12.csv',
                    'NSBS-Elise-2024-08-08.csv', 'NSBS-Eva.csv', 'NSBS-Fiesty.csv', 'NSBS-Finnigan-14.csv',
                    'NSBS-Finnigan.csv', 'NSBS-GABBY.csv', 'NSBS-GRIFFIN.csv', 'NSBS-Gwen-2022-08-03.csv',
                    'NSBS-HUGH.csv', 'NSBS-Hayley.csv', 'NSBS-Haze-2023-08-15.csv', 'NSBS-Helga.csv',
                    'NSBS-Hey Jude.csv', 'NSBS-Holli-2024-08-07.csv', 'NSBS-Hooker.csv', 'NSBS-Hops.csv',
                    'NSBS-Iara-2019-08-12.csv', 'NSBS-Janina.csv', 'NSBS-Jen-2024-08-09.csv', 'NSBS-Juno-2024-08-13.csv',
                    'NSBS-KRISTINA.csv', 'NSBS-Katelyn.csv', 'NSBS-Kaylee-2019-08-12.csv', 'NSBS-Keesh.csv',
                    'NSBS-LORENZA.csv', 'NSBS-Leia.csv', 'NSBS-Level Best-2019-08-12.csv', 'NSBS-Lindsay.csv',
                    'NSBS-Lips-2019-08-25.csv', 'NSBS-Lise.csv', 'NSBS-Lola.csv', 'NSBS-Lucy-14.csv',
                    'NSBS-Lucy.csv', 'NSBS-Lula-2023-08-21.csv', 'NSBS-MOFFAT.csv', 'NSBS-Mackenzie-2019-08-25.csv',
                    'NSBS-Marley.csv', 'NSBS-Meeko.csv', 'NSBS-Mick-2024-08-08.csv', 'NSBS-Mrs. F.csv',
                    'NSBS-NAKIA.csv', 'NSBS-NICOLE.csv', 'NSBS-Nessie.csv', 'NSBS-Nikki.csv',
                    'NSBS-Not so lucky.csv', 'NSBS-Nymeria-2023-08-21.csv', 'NSBS-OTBS-1-2021-08-23.csv',
                    'NSBS-OTBS-2-2021-08-23.csv', 'NSBS-OTBS-2024-01-2024-08-19.csv', 'NSBS-OTBS-2024-02-2024-08-20.csv',
                    'NSBS-OTBS-3-2021-08-23.csv', 'NSBS-OTBS-5-2022-08-24.csv', 'NSBS-OTBS-6-2022-08-24.csv',
                    'NSBS-OTBS-7-2022-08-25.csv', 'NSBS-OTBS-8-2022-08-25.csv', 'NSBS-Ophelia.csv',
                    'NSBS-PEYTON.csv', 'NSBS-Percy.csv', 'NSBS-Princess-2019-08-12.csv', 'NSBS-Quillie-2022-08-16.csv',
                    'NSBS-Riley.csv', 'NSBS-Roseanne.csv', 'NSBS-Roxanne-2021-08-10.csv', 'NSBS-SARAH.csv',
                    'NSBS-SWAANTJE.csv', 'NSBS-Sailor.csv', 'NSBS-Salty Dog.csv', 'NSBS-Sam-2019-08-25.csv',
                    'NSBS-Scotch-2021-08-24.csv', 'NSBS-Scotty.csv', 'NSBS-Skylar.csv', 'NSBS-Sophie.csv',
                    'NSBS-Spruce.csv', 'NSBS-Stitch-2023-08-21.csv', 'NSBS-Suzy Q.csv', 'NSBS-TINI.csv',
                    'NSBS-TRACEY.csv', 'NSBS-Tail Slap.csv', 'NSBS-Taylor-2023-08-03.csv', 'NSBS-Tika.csv',
                    'NSBS-Tiny Turner.csv', 'NSBS-Whitney-2022-08-03.csv', 'NSBS-Wryley.csv', 'NSBS-Xena.csv'
                ];

                // Load all shark tracking files
                const sharkPromises = sharkFiles.map(async (filename, index) => {
                    try {
                        const response = await fetch(`data/blue-shark-gbif/${filename}`);
                        const csvText = await response.text();
                        const parsedData = Papa.parse(csvText, { header: true, skipEmptyLines: true });
                        
                        parsedData.data.forEach(row => {
                            const id = row.id;
                            const lat = parseFloat(row.lat);
                            const lon = parseFloat(row.lon);
                            const date = new Date(row.date);
                            
                            if (!isNaN(lat) && !isNaN(lon) && !isNaN(date.getTime())) {
                                if (!sharkData[id]) {
                                    sharkData[id] = [];
                                }
                                sharkData[id].push({
                                    lat: lat,
                                    lon: lon,
                                    date: date
                                });
                                
                                allBounds.push([lat, lon]);
                            }
                        });
                        
                        return filename;
                    } catch (error) {
                        console.warn(`Failed to load ${filename}:`, error);
                        return null;
                    }
                });

                // Wait for all shark files to load
                const results = await Promise.all(sharkPromises);
                const successfulLoads = results.filter(r => r !== null);
                
                console.log(`Successfully loaded ${successfulLoads.length} out of ${sharkFiles.length} shark files`);

                // Sort tracking data by date for each shark
                Object.keys(sharkData).forEach(id => {
                    sharkData[id].sort((a, b) => a.date - b.date);
                });

                console.log('Loaded data:', Object.keys(sharkData).length, 'unique sharks');
                
                updateStats();
                createSharkLayers();
                populateSharkList();
                
                // Initialize legend content
                updateLegendContent();
                
                // Fit map to show all sharks on initial load
                if (allBounds.length > 0) {
                    const bounds = L.latLngBounds(allBounds);
                    map.fitBounds(bounds.pad(0.1));
                }
                
            } catch (error) {
                console.error('Error loading data:', error);
                showNotification('Error loading shark data. Please check console for details.', 5000);
            }
        }

        // Update statistics
        function updateStats() {
            const totalSharks = Object.keys(sharkData).length;
            const totalPoints = Object.values(sharkData).reduce((sum, track) => sum + track.length, 0);
            
            let minDate = new Date();
            let maxDate = new Date(0);
            
            Object.values(sharkData).forEach(track => {
                track.forEach(point => {
                    if (point.date < minDate) minDate = point.date;
                    if (point.date > maxDate) maxDate = point.date;
                });
            });

            document.getElementById('total-sharks').textContent = totalSharks;
            document.getElementById('total-points').textContent = totalPoints.toLocaleString();
            
            const dateOptions = { year: 'numeric', month: 'short' };
            document.getElementById('date-range').textContent = 
                `${minDate.toLocaleDateString('en-US', dateOptions)} - ${maxDate.toLocaleDateString('en-US', dateOptions)}`;
        }

        // Create map layers for each shark
        function createSharkLayers() {
            let colorIndex = 0;
            
            Object.keys(sharkData).forEach(sharkId => {
                const track = sharkData[sharkId];
                const color = colors[colorIndex % colors.length];
                colorIndex++;
                
                const layerGroup = L.layerGroup();
                
                // Create track polyline
                const latlngs = track.map(point => [point.lat, point.lon]);
                const polyline = L.polyline(latlngs, {
                    color: color,
                    weight: 2,
                    opacity: 0.7
                });
                
                // Add start marker (deployment)
                const startPoint = track[0];
                const startMarker = L.circleMarker([startPoint.lat, startPoint.lon], {
                    radius: 6,
                    fillColor: '#e74c3c',
                    color: '#fff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.9
                });
                
                // Add end marker
                const endPoint = track[track.length - 1];
                const endMarker = L.circleMarker([endPoint.lat, endPoint.lon], {
                    radius: 6,
                    fillColor: '#27ae60',
                    color: '#fff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.9
                });

                // Create popup content
                const displayName = sharkId.replace('NSBS-', '');
                const popupContent = `
                    <div style="font-family: Arial, sans-serif;">
                        <h4 style="margin: 0 0 10px 0; color: #2c3e50;">Shark: ${displayName}</h4>
                        <p><strong>Species:</strong> Blue Shark (Prionace glauca)</p>
                        <p><strong>Track Duration:</strong> ${Math.round((endPoint.date - startPoint.date) / (1000 * 60 * 60 * 24))} days</p>
                        <p><strong>Total Points:</strong> ${track.length.toLocaleString()}</p>
                        <p><strong>Distance Traveled:</strong> ~${calculateDistance(track).toFixed(0)} km</p>
                        <p><strong>First Date:</strong> ${startPoint.date.toLocaleDateString()}</p>
                        <p><strong>Last Date:</strong> ${endPoint.date.toLocaleDateString()}</p>
                    </div>
                `;
                
                polyline.bindPopup(popupContent);
                startMarker.bindPopup(`<strong>Start Location</strong><br/>${popupContent}`);
                endMarker.bindPopup(`<strong>Last Known Position</strong><br/>${popupContent}`);
                
                layerGroup.addLayer(polyline);
                layerGroup.addLayer(startMarker);
                layerGroup.addLayer(endMarker);
                
                sharkLayers[sharkId] = {
                    layer: layerGroup,
                    color: color
                };
                
                layerGroup.addTo(map);
            });
        }

        // Populate shark list in sidebar
        function populateSharkList() {
            const listContainer = document.getElementById('shark-list');
            listContainer.innerHTML = '';
            
            // Sort sharks by ID
            const sortedSharkIds = Object.keys(sharkData).sort();
            
            sortedSharkIds.forEach(sharkId => {
                const track = sharkData[sharkId];
                const sharkLayer = sharkLayers[sharkId];
                
                const item = document.createElement('div');
                item.className = 'shark-item';
                item.dataset.sharkId = sharkId;
                
                const duration = Math.round((track[track.length - 1].date - track[0].date) / (1000 * 60 * 60 * 24));
                const displayName = sharkId.replace('NSBS-', '');
                
                item.innerHTML = `
                    <div class="shark-id" style="color: ${sharkLayer.color};">
                        ðŸ¦ˆ ${displayName}
                    </div>
                    <div class="shark-details">
                        <div><strong>Duration:</strong> ${duration} days</div>
                        <div><strong>Points:</strong> ${track.length.toLocaleString()}</div>
                        <div><strong>Start:</strong> ${track[0].date.toLocaleDateString()}</div>
                    </div>
                `;
                
                item.addEventListener('click', () => {
                    // Highlight selected shark
                    document.querySelectorAll('.shark-item').forEach(el => el.classList.remove('selected'));
                    item.classList.add('selected');
                    
                    selectedSharkId = sharkId;
                    
                    if (showOneMode) {
                        // Show One mode: Hide all others, show only this shark
                        Object.keys(sharkLayers).forEach(id => {
                            const layer = sharkLayers[id].layer;
                            if (id === sharkId) {
                                if (!map.hasLayer(layer)) {
                                    map.addLayer(layer);
                                }
                            } else {
                                if (map.hasLayer(layer)) {
                                    map.removeLayer(layer);
                                }
                            }
                        });
                    }
                    
                    // Zoom to selected shark
                    const bounds = L.latLngBounds(track.map(point => [point.lat, point.lon]));
                    map.fitBounds(bounds.pad(0.2));
                    
                    // Open popup
                    sharkLayer.layer.eachLayer(layer => {
                        if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
                            layer.openPopup();
                        }
                    });
                });
                
                listContainer.appendChild(item);
            });
        }

        // Old commented code removed
        /*
        OLD populateSharkList() {
            const listContainer = document.getElementById('shark-list');
            listContainer.innerHTML = '';
            
            // Sort sharks by deployment year and ID
            const sortedSharkIds = Object.keys(sharkData).sort();
            
            sortedSharkIds.forEach(sharkId => {
                const track = sharkData[sharkId];
                const metadata = sharkMetadata[sharkId] || {};
                const sharkLayer = sharkLayers[sharkId];
                
                const item = document.createElement('div');
                item.className = 'shark-item';
                item.dataset.sharkId = sharkId;
                
                const duration = Math.round((track[track.length - 1].date - track[0].date) / (1000 * 60 * 60 * 24));
                
                // Extract year and simplified ID from shark ID
                // Match the year which comes after the initial 160424_ prefix
                const yearMatch = sharkId.match(/160424_(\d{4})/);
                const year = yearMatch ? yearMatch[1] : sharkId.match(/(\d{4})/)[1];
                const shortId = sharkId.replace('160424_', '').replace(`${year}_`, '').replace('pnas_atn', '').replace('_filtered', '');
                
                item.innerHTML = `
                    <div class="shark-id" style="color: ${sharkLayer.color};">
                        ðŸ¦ˆ Shark ${shortId} (${year})
                    </div>
                    <div class="shark-details">
                        <div><strong>Length:</strong> ${metadata.length ? metadata.length + ' cm' : 'Unknown'}</div>
                        <div><strong>Duration:</strong> ${duration} days</div>
                        <div><strong>Points:</strong> ${track.length.toLocaleString()}</div>
                        <div><strong>Status:</strong> ${metadata.endType || 'Unknown'}</div>
                        <div><strong>Sex:</strong> ${metadata.sex || 'Unknown'}</div>
                    </div>
                    <button class="shark-visibility-toggle" data-shark-id="${sharkId}" title="Toggle visibility">
                        ${sharkLayer.visible ? EYE_VISIBLE_ICON : EYE_HIDDEN_ICON}
                    </button>
                `;
                
                item.addEventListener('click', (e) => {
                    // Don't trigger if clicking the toggle button
                    if (e.target.closest('.shark-visibility-toggle')) {
                        return;
                    }
                    
                    // Highlight selected shark
                    document.querySelectorAll('.shark-item').forEach(el => el.classList.remove('selected'));
                    item.classList.add('selected');
                    
                    if (showOneMode) {
                        // Show One mode: Enable time slider for this shark
                        selectedSharkId = sharkId;
                        currentEnvironmentalMonth = null; // Reset month tracking when selecting new shark
                        document.getElementById('shark-list').style.opacity = '1';
                        
                        // Hide all other tracks
                        Object.values(sharkLayers).forEach(shark => {
                            if (shark.visible) {
                                map.removeLayer(shark.layer);
                                shark.visible = false;
                            }
                        });
                        
                        // Show time slider and initialize visualization
                        showTimeSlider(sharkId);
                        updateSharkVisualization();
                        
                        // Update legend content for show one mode
                        updateLegendContent();
                        
                    } else {
                        selectedSharkId = sharkId;
                        // Normal mode: Show track and zoom
                        const bounds = L.latLngBounds(track.map(point => [point.lat, point.lon]));
                        map.fitBounds(bounds.pad(0.2));
                        
                        // Open popup for the shark
                        sharkLayer.layer.eachLayer(layer => {
                            if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
                                layer.openPopup();
                            }
                        });
                    }
                });

                // Add event listener for visibility toggle button
                const toggleButton = item.querySelector('.shark-visibility-toggle');
                toggleButton.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent shark selection
                    
                    const sharkLayer = sharkLayers[sharkId];
                    if (sharkLayer.visible) {
                        // Hide the shark
                        map.removeLayer(sharkLayer.layer);
                        sharkLayer.visible = false;
                        toggleButton.innerHTML = EYE_HIDDEN_ICON;
                    } else {
                        // Show the shark
                        map.addLayer(sharkLayer.layer);
                        sharkLayer.visible = true;
                        toggleButton.innerHTML = EYE_VISIBLE_ICON;
                    }
                    
                    // Update legend content when visibility changes
                    updateLegendContent();
                });
                
                listContainer.appendChild(item);
            });
            
            // Update visibility toggle buttons after populating the list
            updateVisibilityToggleButtons();
        }

        // Function to update visibility toggle buttons based on current mode
        function updateVisibilityToggleButtons() {
            const toggleButtons = document.querySelectorAll('.shark-visibility-toggle');
            const chlorophyllButton = document.getElementById('toggle-chlorophyll');
            const sstButton = document.getElementById('toggle-sst');
            const pocButton = document.getElementById('toggle-poc');
            
            if (showOneMode) {
                // Hide all shark toggle buttons in Show One mode
                toggleButtons.forEach(button => {
                    button.classList.add('hidden');
                });
                
                // Enable environmental layer buttons in Show One mode
                if (chlorophyllButton) {
                    chlorophyllButton.disabled = false;
                    chlorophyllButton.style.opacity = '1';
                }
                if (sstButton) {
                    sstButton.disabled = false;
                    sstButton.style.opacity = '1';
                }
                if (pocButton) {
                    pocButton.disabled = false;
                    pocButton.style.opacity = '1';
                }
            } else {
                // Show all shark toggle buttons in Show All/Hide All modes
                toggleButtons.forEach(button => {
                    button.classList.remove('hidden');
                    const sharkId = button.dataset.sharkId;
                    const sharkLayer = sharkLayers[sharkId];
                    
                    // Update icon based on visibility
                    if (sharkLayer && sharkLayer.visible) {
                        button.innerHTML = EYE_VISIBLE_ICON;
                    } else {
                        button.innerHTML = EYE_HIDDEN_ICON;
                    }
                });
                
                // Disable environmental layer buttons outside Show One mode
                if (chlorophyllButton) {
                    chlorophyllButton.disabled = true;
                    chlorophyllButton.style.opacity = '0.5';
                }
                if (sstButton) {
                    sstButton.disabled = true;
                    sstButton.style.opacity = '0.5';
                }
                if (pocButton) {
                    pocButton.disabled = true;
                    pocButton.style.opacity = '0.5';
                }
            }
        }
        */

        // Fit map to show all shark data
        function fitMapToVisibleSharks() {
            if (allBounds.length > 0) {
                const bounds = L.latLngBounds(allBounds);
                map.fitBounds(bounds.pad(0.1));
            }
        }

        // Event listeners for controls
        function setupEventListeners() {
            // Legend toggle
            document.getElementById('legend').addEventListener('click', toggleLegend);
            
            // Menu toggle button
            document.getElementById('menu-toggle').addEventListener('click', () => {
                const sidebar = document.getElementById('sidebar');
                const container = document.querySelector('.container');
                
                sidebar.classList.toggle('hidden');
                container.classList.toggle('sidebar-hidden');
                
                // Trigger map resize after animation completes
                setTimeout(() => {
                    map.invalidateSize();
                }, 300);
            });
            
            // Show All button
            document.getElementById('show-all').addEventListener('click', () => {
                showOneMode = false;
                
                // Show all sharks
                Object.values(sharkLayers).forEach(shark => {
                    if (!map.hasLayer(shark.layer)) {
                        map.addLayer(shark.layer);
                    }
                });
                
                // Update button states
                document.getElementById('show-all').classList.add('active');
                document.getElementById('show-one').classList.remove('active');
                
                // Fit map to all sharks
                fitMapToVisibleSharks();
            });
            
            // Show One button
            document.getElementById('show-one').addEventListener('click', () => {
                showOneMode = true;
                
                // Update button states
                document.getElementById('show-one').classList.add('active');
                document.getElementById('show-all').classList.remove('active');
                
                // If a shark is already selected, show only that one
                if (selectedSharkId && sharkLayers[selectedSharkId]) {
                    Object.keys(sharkLayers).forEach(id => {
                        const layer = sharkLayers[id].layer;
                        if (id === selectedSharkId) {
                            if (!map.hasLayer(layer)) {
                                map.addLayer(layer);
                            }
                        } else {
                            if (map.hasLayer(layer)) {
                                map.removeLayer(layer);
                            }
                        }
                    });
                    
                    // Zoom to selected shark
                    const track = sharkData[selectedSharkId];
                    const bounds = L.latLngBounds(track.map(point => [point.lat, point.lon]));
                    map.fitBounds(bounds.pad(0.2));
                } else {
                    // Hide all sharks until one is selected
                    Object.values(sharkLayers).forEach(shark => {
                        if (map.hasLayer(shark.layer)) {
                            map.removeLayer(shark.layer);
                        }
                    });
                    showNotification('Click on a shark in the list below to view its track!');
                }
            });
            
            // MPA toggle event listener
            document.getElementById('toggle-mpa').addEventListener('click', toggleMPALayer);
        }
        
        // Dummy function left for compatibility (removing these functions)
        function setupMapInteractionListeners() {
            // No longer needed
        }
        
        // Removed: show-all, hide-all, show-one, toggle-points, environmental layers,
        // time slider, play controls, follow mode, etc.
        
        // Old setupEventListeners function removed - replaced above with minimal version
        /*
        OLD CODE REMOVED:
            document.getElementById('show-all').addEventListener('click', () => {
                showOneMode = false;
                selectedSharkId = null;
                hideTimeSlider();
                
                // Hide environmental layers when leaving Show One mode
                if (chlorophyllLayer && map.hasLayer(chlorophyllLayer)) {
                    map.removeLayer(chlorophyllLayer);
                }
                if (sstLayer && map.hasLayer(sstLayer)) {
                    map.removeLayer(sstLayer);
                }
                if (pocLayer && map.hasLayer(pocLayer)) {
                    map.removeLayer(pocLayer);
                }
                
                // Reset environmental layer states and button appearances
                showChlorophyll = false;
                showSST = false;
                showPOC = false;
                currentEnvironmentalMonth = null; // Reset month tracking
                const chlButton = document.getElementById('toggle-chlorophyll');
                const sstButton = document.getElementById('toggle-sst');
                const pocButton = document.getElementById('toggle-poc');
                if (chlButton) {
                    chlButton.classList.remove('active');
                    chlButton.textContent = 'Chlorophyll';
                }
                if (sstButton) {
                    sstButton.classList.remove('active');
                    sstButton.textContent = 'Sea Surface Temp';
                }
                if (pocButton) {
                    pocButton.classList.remove('active');
                    pocButton.textContent = 'POC';
                }
                
                // Hide color scales
                document.getElementById('chl-scale').classList.remove('visible');
                document.getElementById('sst-scale').classList.remove('visible', 'with-chl-scale');
                document.getElementById('poc-scale').classList.remove('visible', 'with-chl-scale', 'with-sst-scale');
                
                Object.values(sharkLayers).forEach(shark => {
                    if (!shark.visible) {
                        map.addLayer(shark.layer);
                        shark.visible = true;
                    }
                });
                document.getElementById('show-all').classList.add('active');
                document.getElementById('hide-all').classList.remove('active');
                document.getElementById('show-one').classList.remove('active');
                
                // Reset shark list opacity
                document.getElementById('shark-list').style.opacity = '1';
                
                // Update visibility toggle buttons
                updateVisibilityToggleButtons();
                
                // Update legend content
                updateLegendContent();

                // Update max zoom
                updateMaxZoom();
            });
            
            document.getElementById('hide-all').addEventListener('click', () => {
                Object.values(sharkLayers).forEach(shark => {
                    if (shark.visible) {
                        map.removeLayer(shark.layer);
                        shark.visible = false;
                    }
                });
                document.getElementById('hide-all').classList.add('active');
                document.getElementById('show-all').classList.remove('active');
                document.getElementById('show-one').classList.remove('active');
                showOneMode = false;
                hideTimeSlider();
                
                // Hide environmental layers when leaving Show One mode
                if (chlorophyllLayer && map.hasLayer(chlorophyllLayer)) {
                    map.removeLayer(chlorophyllLayer);
                }
                if (sstLayer && map.hasLayer(sstLayer)) {
                    map.removeLayer(sstLayer);
                }
                if (pocLayer && map.hasLayer(pocLayer)) {
                    map.removeLayer(pocLayer);
                }
                
                // Reset environmental layer states and button appearances
                showChlorophyll = false;
                showSST = false;
                showPOC = false;
                currentEnvironmentalMonth = null; // Reset month tracking
                const chlButton = document.getElementById('toggle-chlorophyll');
                const sstButton = document.getElementById('toggle-sst');
                const pocButton = document.getElementById('toggle-poc');
                if (chlButton) {
                    chlButton.classList.remove('active');
                    chlButton.textContent = 'Chlorophyll';
                }
                if (sstButton) {
                    sstButton.classList.remove('active');
                    sstButton.textContent = 'Sea Surface Temp';
                }
                if (pocButton) {
                    pocButton.classList.remove('active');
                    pocButton.textContent = 'POC';
                }
                
                // Hide color scales
                document.getElementById('chl-scale').classList.remove('visible');
                document.getElementById('sst-scale').classList.remove('visible', 'with-chl-scale');
                document.getElementById('poc-scale').classList.remove('visible', 'with-chl-scale', 'with-sst-scale');
                
                // Update visibility toggle buttons
                updateVisibilityToggleButtons();
                
                // Update legend content
                updateLegendContent();

                // Update max zoom
                updateMaxZoom();
            });
            
            document.getElementById('show-one').addEventListener('click', () => {
                showOneMode = true;
                // Hide all tracks first
                Object.values(sharkLayers).forEach(shark => {
                    if (shark.visible) {
                        map.removeLayer(shark.layer);
                        shark.visible = false;
                    }
                });
                
                // Update button states
                document.getElementById('show-one').classList.add('active');
                document.getElementById('show-all').classList.remove('active');
                document.getElementById('hide-all').classList.remove('active');
                
                // Update visibility toggle buttons to hide them in Show One mode
                updateVisibilityToggleButtons();
                
                // Update legend content
                updateLegendContent();
                
                // If a shark was already selected, update the visualization
                if (selectedSharkId && sharkData[selectedSharkId]) {
                    // Reset month tracking for environmental layers
                    currentEnvironmentalMonth = null;
                    
                    // Show time slider and update visualization
                    showTimeSlider(selectedSharkId);
                    updateSharkVisualization();
                    
                    // Update environmental layers if any are enabled
                    updateEnvironmentalLayers();
                    
                    // Highlight the selected shark in the list
                    document.querySelectorAll('.shark-item').forEach(item => {
                        if (item.dataset.sharkId === selectedSharkId) {
                            item.classList.add('selected');
                        } else {
                            item.classList.remove('selected');
                        }
                    });
                } else {
                    // Show instruction message only if no shark is selected
                    showNotification('Click on a shark in the list below to view its track over time!');
                }
            });
            
            // Fit to Data button
            document.getElementById('fit-bounds').addEventListener('click', () => {
                // If in show one mode and a shark is selected, fit to that shark's complete track
                if (showOneMode && selectedSharkId && sharkData[selectedSharkId]) {
                    const track = sharkData[selectedSharkId];
                    const allLatLngs = track.map(point => [point.lat, point.lon]);
                    const bounds = L.latLngBounds(allLatLngs);
                    map.fitBounds(bounds.pad(0.1));
                } else {
                    // Use the reusable function for fitting to visible sharks
                    fitMapToVisibleSharks();
                }
            });
            
            document.getElementById('toggle-points').addEventListener('click', () => {
                showPoints = !showPoints;
                
                // Update button appearance and text based on state
                const toggleButton = document.getElementById('toggle-points');
                if (showPoints) {
                    toggleButton.classList.add('active');
                    toggleButton.textContent = 'Hide Points';
                } else {
                    toggleButton.classList.remove('active');
                    toggleButton.textContent = 'Show Points';
                }
                
                if (showOneMode && selectedSharkId) {
                    // In Show One mode, only update the current shark's visualization
                    updateSharkVisualization();
                } else {
                    // In normal mode, recreate all layers with/without points
                    Object.values(sharkLayers).forEach(shark => {
                        map.removeLayer(shark.layer);
                    });
                    sharkLayers = {};
                    createSharkLayers();
                    // Repopulate shark list to restore event handlers
                    populateSharkList();
                }
            });
            
            // MPA toggle event listener
            document.getElementById('toggle-mpa').addEventListener('click', toggleMPALayer);
            
            // Environmental layer toggle event listeners
            document.getElementById('toggle-chlorophyll').addEventListener('click', toggleChlorophyllLayer);
            document.getElementById('toggle-sst').addEventListener('click', toggleSSTLayer);
            document.getElementById('toggle-poc').addEventListener('click', togglePOCLayer);
            
            // Bottom time slider event listener
            document.getElementById('bottom-time-slider').addEventListener('input', (e) => {
                if (selectedSharkId && sharkData[selectedSharkId]) {
                    const percentage = e.target.value / 100;
                    const track = sharkData[selectedSharkId];
                    currentTimeIndex = Math.floor((track.length - 1) * percentage);
                    updateTimeSliderDisplay();
                    updateSharkVisualization();
                    
                    // Pause animation when user manually changes slider
                    if (isPlaying) {
                        pauseAnimation();
                    }
                }
            });
            
            // Play/Pause button
            document.getElementById('play-button').addEventListener('click', () => {
                if (isPlaying) {
                    pauseAnimation();
                } else {
                    startAnimation();
                }
            });
            
            // Speed control buttons
            document.querySelectorAll('.speed-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    // Update active speed button
                    document.querySelectorAll('.speed-button').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    // Update play speed
                    playSpeed = parseFloat(e.target.dataset.speed);
                    
                    // Restart animation if playing
                    if (isPlaying) {
                        pauseAnimation();
                        startAnimation();
                    }
                });
            });
            
            // Follow button
            document.getElementById('follow-button').addEventListener('click', (e) => {
                followMode = !followMode;
                const button = e.target;
                if (followMode) {
                    button.classList.add('active');
                    button.textContent = 'ðŸ¦ˆ Following';
                } else {
                    button.classList.remove('active');
                    button.textContent = 'ðŸ¦ˆ Follow';
                }
            });
            
            // Map dragging control for bottom time controls
            const bottomControls = document.getElementById('bottom-time-controls');
            bottomControls.addEventListener('mouseenter', () => {
                map.dragging.disable();
                map.doubleClickZoom.disable();
                map.scrollWheelZoom.disable();
            });
            
            bottomControls.addEventListener('mouseleave', () => {
                map.dragging.enable();
                map.doubleClickZoom.enable();
                map.scrollWheelZoom.enable();
            });
            
            // Scroll zoom toggle
            document.getElementById('toggle-scroll-zoom').addEventListener('click', (e) => {
                const button = e.target;
                if (button.classList.contains('active')) {
                    // Disable scroll zoom
                    map.scrollWheelZoom.disable();
                    button.classList.remove('active');
                    showNotification('Scroll zoom disabled');
                } else {
                    // Enable scroll zoom
                    map.scrollWheelZoom.enable();
                    button.classList.add('active');
                    showNotification('Scroll zoom enabled');
                }
            });
            
            // Initialize toggle points button state
            const toggleButton = document.getElementById('toggle-points');
            if (showPoints) {
                toggleButton.classList.add('active');
                toggleButton.textContent = 'Hide Points';
            } else {
                toggleButton.classList.remove('active');
                toggleButton.textContent = 'Show Points';
            }
            
            // Initialize environmental layer buttons to be disabled by default
            const chlorophyllButton = document.getElementById('toggle-chlorophyll');
            const sstButton = document.getElementById('toggle-sst');
            if (chlorophyllButton) {
                chlorophyllButton.disabled = true;
                chlorophyllButton.style.opacity = '0.5';
            }
            if (sstButton) {
                sstButton.disabled = true;
                sstButton.style.opacity = '0.5';
            }
            
            // Initialize time slider text color
            updateTimeSliderTextColor();
        }
        
        // Helper function to disable follow mode
        function disableFollowMode() {
            if (followMode) {
                followMode = false;
                const followButton = document.getElementById('follow-button');
                followButton.classList.remove('active');
                followButton.textContent = 'ðŸ¦ˆ Follow';
            }
        }
        
        // Set up map interaction listeners (called after map initialization)
        function setupMapInteractionListeners() {
            map.on('dragstart', disableFollowMode);
        }
        
        // Show time slider
        function showTimeSlider(sharkId) {
            const bottomContainer = document.getElementById('bottom-time-controls');
            bottomContainer.classList.add('visible');
            
            const track = sharkData[sharkId];
            const metadata = sharkMetadata[sharkId] || {};
            // Match the year which comes after the initial 160424_ prefix
            const yearMatch = sharkId.match(/160424_(\d{4})/);
            const year = yearMatch ? yearMatch[1] : sharkId.match(/(\d{4})/)[1];
            const shortId = sharkId.replace('160424_', '').replace(`${year}_`, '').replace('pnas_atn', '').replace('_filtered', '');
            
            // Update bottom controls (no need to check for elements since they're commented out)
            // document.getElementById('bottom-control-title').textContent = `Shark ${shortId} (${year})`;
            // document.getElementById('bottom-control-info').textContent = `${track.length} points â€¢ ${Math.round((track[track.length - 1].date - track[0].date) / (1000 * 60 * 60 * 24))} days`;
            
            // Set up time display
            const startDate = track[0].date.toLocaleDateString();
            const endDate = track[track.length - 1].date.toLocaleDateString();
            
            // Bottom time display
            document.getElementById('bottom-start-time').textContent = startDate;
            document.getElementById('bottom-end-time').textContent = endDate;
            document.getElementById('bottom-current-time').textContent = endDate;
            
            // Set slider to end (100%)
            document.getElementById('bottom-time-slider').value = 100;
            currentTimeIndex = track.length - 1;
            
            // Move scale control up to avoid collision with time slider
            const scaleControl = document.querySelector('.leaflet-control-scale');
            if (scaleControl) {
                scaleControl.style.bottom = '90px';
                scaleControl.style.transition = 'bottom 0.3s ease';
            }
        }
        
        // Hide time slider
        function hideTimeSlider() {
            const bottomContainer = document.getElementById('bottom-time-controls');
            bottomContainer.classList.remove('visible');
            
            // Stop any playing animation
            pauseAnimation();
            
            if (timeSliderLayer) {
                map.removeLayer(timeSliderLayer);
                timeSliderLayer = null;
            }
            
            // Move scale control back to original position
            const scaleControl = document.querySelector('.leaflet-control-scale');
            if (scaleControl) {
                scaleControl.style.bottom = '10px';
                scaleControl.style.transition = 'bottom 0.3s ease';
            }
        }
        
        // Update time slider display
        function updateTimeSliderDisplay() {
            if (selectedSharkId && sharkData[selectedSharkId]) {
                const track = sharkData[selectedSharkId];
                const currentDate = track[currentTimeIndex].date.toLocaleDateString();
                document.getElementById('bottom-current-time').textContent = currentDate;
            }
        }
        
        // Start animation
        function startAnimation() {
            if (!selectedSharkId || !sharkData[selectedSharkId] || isPlaying) return;
            
            const track = sharkData[selectedSharkId];
            
            // If we're at the end, reset to the beginning
            if (currentTimeIndex >= track.length - 1) {
                currentTimeIndex = 0;
                // Update slider and display immediately
                document.getElementById('bottom-time-slider').value = 0;
                updateTimeSliderDisplay();
                updateSharkVisualization();
            }
            
            // Close any open popups when animation starts
            if (timeSliderLayer) {
                timeSliderLayer.eachLayer(layer => {
                    if (layer instanceof L.CircleMarker && layer.isPopupOpen()) {
                        layer.closePopup();
                    }
                });
            }
            
            isPlaying = true;
            document.getElementById('play-button').textContent = 'â¸';
            document.getElementById('play-button').classList.add('playing');
            
            const delay = playStepDelay / playSpeed;
            
            playInterval = setInterval(() => {
                if (currentTimeIndex >= track.length - 1) {
                    // Reached the end, stop animation
                    pauseAnimation();
                    return;
                } else {
                    currentTimeIndex++;
                }
                
                // Update slider position
                const percentage = (currentTimeIndex / (track.length - 1)) * 100;
                document.getElementById('bottom-time-slider').value = percentage;
                
                // Update display and visualization
                updateTimeSliderDisplay();
                updateSharkVisualization();
                
            }, delay);
        }
        
        // Pause animation
        function pauseAnimation() {
            if (!isPlaying) return;
            
            isPlaying = false;
            document.getElementById('play-button').textContent = 'â–¶';
            document.getElementById('play-button').classList.remove('playing');
            
            if (playInterval) {
                clearInterval(playInterval);
                playInterval = null;
            }
            
            // Show current marker popup when animation is paused
            setTimeout(() => {
                if (currentMarker && currentMarker._map) {
                    currentMarker.openPopup();
                }
            }, 100); // Small delay to ensure layer is fully rendered and added to map
        }
        
        // Update shark visualization based on time slider
        function updateSharkVisualization() {
            if (!selectedSharkId || !sharkData[selectedSharkId]) return;
            
            // Remove existing time slider layer
            if (timeSliderLayer) {
                map.removeLayer(timeSliderLayer);
            }
            
            const track = sharkData[selectedSharkId];
            const color = sharkLayers[selectedSharkId].color;
            
            timeSliderLayer = L.layerGroup();
            
            // Draw the complete track with two segments: past and future
            const allLatLngs = track.map(point => [point.lat, point.lon]);
            
            if (track.length > 1) {
                // Past segment (from start to current position) - full opacity
                if (currentTimeIndex > 0) {
                    const pastLatLngs = allLatLngs.slice(0, currentTimeIndex + 1);
                    const pastPolyline = L.polyline(pastLatLngs, {
                        color: color,
                        weight: 4,
                        opacity: 0.8
                    });
                    timeSliderLayer.addLayer(pastPolyline);
                }
                
                // Future segment (from current position to end) - reduced opacity
                if (currentTimeIndex < track.length - 1) {
                    const futureLatLngs = allLatLngs.slice(currentTimeIndex);
                    const futurePolyline = L.polyline(futureLatLngs, {
                        color: color,
                        weight: 4,
                        opacity: 0.3
                    });
                    timeSliderLayer.addLayer(futurePolyline);
                }
            }
            
            // Add start marker (deployment location)
            const startPoint = track[0];
            const startMarker = L.circleMarker([startPoint.lat, startPoint.lon], {
                radius: 10,
                fillColor: '#e74c3c',
                color: '#fff',
                weight: 3,
                opacity: 1,
                fillOpacity: 0.9
            });
            startMarker.bindPopup(`<strong>Deployment Location</strong><br/>Date: ${startPoint.date.toLocaleDateString()}`);
            timeSliderLayer.addLayer(startMarker);
            
            // Add end marker (final location)
            const endPoint = track[track.length - 1];
            const endMarker = L.circleMarker([endPoint.lat, endPoint.lon], {
                radius: 8,
                fillColor: '#27ae60',
                color: '#fff',
                weight: 2,
                opacity: 0.6,
                fillOpacity: 0.6
            });
            endMarker.bindPopup(`<strong>Final Location</strong><br/>Date: ${endPoint.date.toLocaleDateString()}`);
            timeSliderLayer.addLayer(endMarker);
            
            // Add current position marker (shark icon)
            const currentPoint = track[currentTimeIndex];
            currentMarker = L.marker([currentPoint.lat, currentPoint.lon], {
                icon: L.divIcon({
                    html: '<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 24px; background: none !important; border: none !important; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); animation: shark-pulse 2s ease-in-out infinite;">ðŸ¦ˆ</div>',
                    className: 'shark-icon',
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                })
            });
            
            // Calculate distance from start
            const currentTrack = track.slice(0, currentTimeIndex + 1);
            const distanceTraveled = calculateDistance(currentTrack);
            
            currentMarker.bindPopup(`
                <strong>Current Position</strong><br/>
                Date: ${currentPoint.date.toLocaleDateString()}<br/>
                Day ${Math.round((currentPoint.date - startPoint.date) / (1000 * 60 * 60 * 24))} of tracking<br/>
                Location: ${currentPoint.lat.toFixed(4)}, ${currentPoint.lon.toFixed(4)}<br/>
                Quality: ${currentPoint.lc}<br/>
                Distance traveled: ~${distanceTraveled.toFixed(0)} km<br/>
                Progress: ${Math.round((currentTimeIndex / (track.length - 1)) * 100)}%
            `);
            timeSliderLayer.addLayer(currentMarker);
            
            // Add individual points if enabled
            if (showPoints) {
                track.forEach((point, index) => {
                    // Past points: full opacity, Future points: reduced opacity
                    const isPast = index <= currentTimeIndex;
                    const baseOpacity = isPast ? 0.7 : 0.1;
                    const pointMarker = L.circleMarker([point.lat, point.lon], {
                        radius: isPast ? 3 : 2,
                        fillColor: color,
                        color: color,
                        weight: 1,
                        opacity: baseOpacity,
                        fillOpacity: baseOpacity
                    });
                    pointMarker.bindPopup(`
                        Date: ${point.date.toLocaleDateString()}<br/>
                        Location: ${point.lat.toFixed(4)}, ${point.lon.toFixed(4)}<br/>
                        Quality: ${point.lc}<br/>
                        Status: ${isPast ? 'Past' : 'Future'}
                    `);
                    timeSliderLayer.addLayer(pointMarker);
                });
            }
            
            timeSliderLayer.addTo(map);
            
            // Center on current position when follow mode is enabled (no zoom change)
            if (followMode) {
                map.setView([currentPoint.lat, currentPoint.lon]);
            }
            
            // Update environmental layers to match current timestamp
            updateEnvironmentalLayers();
        }

        // Filter sharks by year
        // function filterSharksByYear(year) {
        //     Object.keys(sharkLayers).forEach(sharkId => {
        //         const sharkYear = sharkId.match(/(\d{4})/)[1];
		// 		console.log(sharkId, sharkYear, year);
        //         const shouldShow = year === 'all' || sharkYear === year;
                
        //         if (shouldShow && !sharkLayers[sharkId].visible) {
        //             map.addLayer(sharkLayers[sharkId].layer);
        //             sharkLayers[sharkId].visible = true;
        //         } else if (!shouldShow && sharkLayers[sharkId].visible) {
        //             map.removeLayer(sharkLayers[sharkId].layer);
        //             sharkLayers[sharkId].visible = false;
        //         }
        //     });
            
        //     // Update shark list visibility
        //     document.querySelectorAll('.shark-item').forEach(item => {
        //         const sharkId = item.dataset.sharkId;
        //         const sharkYear = sharkId.match(/(\d{4})/)[1];
        //         const shouldShow = year === 'all' || sharkYear === year;
        //         item.style.display = shouldShow ? 'block' : 'none';
        //     });
        // }

        // Legend management functions (simplified)
        function updateLegendContent() {
            const legendContent = document.getElementById('legend-content');
            
            // Simplified legend - just show markers and MPA if visible
            let content = `
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #e74c3c;"></div>
                    <span class="legend-text">Start Location</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #27ae60;"></div>
                    <span class="legend-text">End Location</span>
                </div>
            `;
            
            if (showMPA && mpaLayer) {
                content += `
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #42a5f5; border: 1px solid #1e88e5;"></div>
                        <span class="legend-text">Marine Protected Areas</span>
                    </div>
                `;
            }
            
            const sharkCount = Object.keys(sharkData).length;
            if (sharkCount > 0) {
                content += `
                    <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #ecf0f1;">
                        <div class="legend-item">
                            <span class="legend-text" style="color: #3498db; font-weight: bold;">${sharkCount} sharks displayed</span>
                        </div>
                    </div>
                `;
            }
            
            legendContent.innerHTML = content;
        }

        // Removed old implementation
        /*
            if (showOneMode && selectedSharkId) {
                // Show One mode - display current position and static markers
                legendContent.innerHTML = `
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #e74c3c;"></div>
                        <span class="legend-text">Deployment Location</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #27ae60;"></div>
                        <span class="legend-text">Final Location</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-emoji">ðŸ¦ˆ</div>
                        <span class="legend-text">Current Position</span>
                    </div>
                    ${showMPA && mpaLayer ? `
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #42a5f5; border: 1px solid #1e88e5;"></div>
                        <span class="legend-text">Marine Protected Areas</span>
                    </div>
                    ` : ''}
                    ${showChlorophyll && chlorophyllLayer ? `
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(90deg, #000080 0%, #0066cc 25%, #00ccff 50%, #66ff66 75%, #ffff00 100%); opacity: 0.6;"></div>
                        <span class="legend-text">Chlorophyll Concentration</span>
                    </div>
                    ` : ''}
                    ${showSST && sstLayer ? `
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(90deg, #000066 0%, #0033cc 25%, #ff3300 50%, #ff9900 75%, #ffcc00 100%); opacity: 0.6;"></div>
                        <span class="legend-text">Sea Surface Temperature</span>
                    </div>
                    ` : ''}
                `;
            } else {
                // Show All/Hide All mode - display visible sharks
                // Use same sorting order as shark list
                const sortedSharkIds = Object.keys(sharkData).sort();
                const visibleSharks = sortedSharkIds.filter(sharkId => 
                    sharkLayers[sharkId] && sharkLayers[sharkId].visible
                );
                
                if (visibleSharks.length === 0) {
                    legendContent.innerHTML = `
                        <div class="legend-item">
                            <span class="legend-text" style="color: #7f8c8d; font-style: italic;">No sharks visible</span>
                        </div>
                    `;
                } else {
                    let content = `
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #e74c3c;"></div>
                            <span class="legend-text">Deployment Location</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #27ae60;"></div>
                            <span class="legend-text">Last Known Position</span>
                        </div>
                        ${showMPA && mpaLayer ? `
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #42a5f5; border: 1px solid #1e88e5;"></div>
                            <span class="legend-text">Marine Protected Areas</span>
                        </div>
                        ` : ''}
                        ${showChlorophyll && chlorophyllLayer ? `
                        <div class="legend-item">
                            <div class="legend-color" style="background: linear-gradient(90deg, #000080 0%, #0066cc 25%, #00ccff 50%, #66ff66 75%, #ffff00 100%); opacity: 0.6;"></div>
                            <span class="legend-text">Chlorophyll Concentration</span>
                        </div>
                        ` : ''}
                        ${showSST && sstLayer ? `
                        <div class="legend-item">
                            <div class="legend-color" style="background: linear-gradient(90deg, #000066 0%, #0033cc 25%, #ff3300 50%, #ff9900 75%, #ffcc00 100%); opacity: 0.6;"></div>
                            <span class="legend-text">Sea Surface Temperature</span>
                        </div>
                        ` : ''}
                    `;
                    
                    // Calculate approximate height to determine if legend would overflow
                    // Base height: ~60px for static items + header
                    // Each shark item: ~22px (including margins)
                    // Available space: roughly viewport height - 120px (for header) - 60px (legend position)
                    const baseHeight = 80; // Static items + padding
                    const itemHeight = 22; // Approximate height per shark item
                    const availableHeight = window.innerHeight - 180; // Account for header and positioning
                    const maxSharkItems = Math.floor((availableHeight - baseHeight) / itemHeight);
                    // console.log('Available height for legend:', availableHeight, 'Max shark items:', maxSharkItems);
                    // console.log('Visible sharks:', visibleSharks.length);
                    
                    if (visibleSharks.length <= maxSharkItems) {
                        // Show individual sharks if they fit without overflowing
                        content += '<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #ecf0f1;"><div class="legend-shark-list">';
                        visibleSharks.forEach(sharkId => {
                            const color = sharkLayers[sharkId].color;
                            const yearMatch = sharkId.match(/160424_(\d{4})/);
                            const year = yearMatch ? yearMatch[1] : sharkId.match(/(\d{4})/)[1];
                            const shortId = sharkId.replace('160424_', '').replace(`${year}_`, '').replace('pnas_atn', '').replace('_filtered', '');
                            
                            content += `
                                <div class="legend-shark-item">
                                    <svg width="20" height="12" style="margin-right: 8px; vertical-align: middle;">
                                        <line x1="2" y1="6" x2="18" y2="6" stroke="${color}" stroke-width="3" stroke-linecap="round"/>
                                    </svg>
                                    <span class="legend-text">Shark ${shortId} (${year})</span>
                                </div>
                            `;
                        });
                        content += '</div></div>';
                    } else {
                        // Show count if legend would overflow the map
                        content += `
                            <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #ecf0f1;">
                                <div class="legend-item">
                                    <span class="legend-text" style="color: #3498db; font-weight: bold;">${visibleSharks.length} sharks visible</span>
                                </div>
                            </div>
                        `;
                    }
                    
                    legendContent.innerHTML = content;
                }
            }
        }
        */
        
        function toggleLegend() {
            const legend = document.getElementById('legend');
            const toggle = legend.querySelector('.legend-toggle');
            
            legend.classList.toggle('collapsed');
            
            if (legend.classList.contains('collapsed')) {
                toggle.textContent = 'â–¶';
                legend.querySelector('.legend-title').textContent = 'View Legend';
            } else {
                toggle.textContent = 'â–¼';
                legend.querySelector('.legend-title').textContent = 'Legend';
                updateLegendContent(); // Refresh content when expanding
            }
        }

        // Initialize everything
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            setupEventListeners();
            loadData();
        });
    </script>
</body>
</html>
